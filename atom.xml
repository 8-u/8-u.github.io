<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>KHUD&#39;s Blog</title>
  
  <subtitle>Welcome!</subtitle>
  <link href="http://8-u.github.io/atom.xml" rel="self"/>
  
  <link href="http://8-u.github.io/"/>
  <updated>2023-01-20T04:23:24.596Z</updated>
  <id>http://8-u.github.io/</id>
  
  <author>
    <name>KHUD</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数据在内存中的存储</title>
    <link href="http://8-u.github.io/posts/6601b08a.html"/>
    <id>http://8-u.github.io/posts/6601b08a.html</id>
    <published>2023-01-20T03:35:46.000Z</published>
    <updated>2023-01-20T04:23:24.596Z</updated>
    
    <content type="html"><![CDATA[<h1 id="【数据在内存中的存储】"><a href="#【数据在内存中的存储】" class="headerlink" title="【数据在内存中的存储】"></a>【数据在内存中的存储】</h1><h2 id="【内存是什么样子的？内存如何分配？】"><a href="#【内存是什么样子的？内存如何分配？】" class="headerlink" title="【内存是什么样子的？内存如何分配？】"></a>【内存是什么样子的？内存如何分配？】</h2><h3 id="【内存的样子】"><a href="#【内存的样子】" class="headerlink" title="【内存的样子】"></a>【内存的样子】</h3><p>内存可以想象成一个连续的物理空间。</p><p><img src="https://c2.im5i.com/2023/01/20/Y5CkD.png" alt="Y5CkD.png"></p><h3 id="【内存的分配】"><a href="#【内存的分配】" class="headerlink" title="【内存的分配】"></a>【内存的分配】</h3><h4 id="【总述】"><a href="#【总述】" class="headerlink" title="【总述】"></a>【总述】</h4><p>内存分配分为三种：静态、栈区、堆区。</p><p><img src="https://c2.im5i.com/2023/01/20/Y5hs2.png" alt="Y5hs2.png"></p><h4 id="【分别解释】"><a href="#【分别解释】" class="headerlink" title="【分别解释】"></a>【分别解释】</h4><p>（1）静态存储区：主要存放static静态变量、全局变量、常量。这些数据内存在编译的时候就已经为他们分配好了内存，生命周期是整个程序从运行到结束。</p><p>（2）栈区：存放局部变量。在执行函数的时候（包括main这样的函数），函数内的局部变量的存储单元会在栈上创建，函数执行完自动释放，生命周期是从该函数的开始执行到结束。</p><p><strong>栈区的使用习惯：先使用高地址，再使用低地址</strong>。</p><p>eg：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">3</span>;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">2</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//【注】：i和arr数组是局部变量，存放在栈区，而栈区使用习惯是先使用高地址，再使用低地址，而且一般的家庭计算机数据存储方式是小端存储，所以i和arr在内存上应该是这样：</span></span><br></pre></td></tr></table></figure><p><img src="https://c2.im5i.com/2023/01/20/Y5QC7.png" alt="Y5QC7.png"></p><p>（3）堆区：程序员自己申请一块任意大小的内存—也叫动态内存分配。这块内存会一直存在直到程序员释放掉。C语言中，用malloc or new动态地申请内存，用free or delete释放内存。良好习惯：若申请的动</p><p>态内存不再使用，要及时释放掉，否则会造成内存泄露。</p><h2 id="【C语言中有那些数据类型呢？】"><a href="#【C语言中有那些数据类型呢？】" class="headerlink" title="【C语言中有那些数据类型呢？】"></a>【C语言中有那些数据类型呢？】</h2><h3 id="【整形家族】"><a href="#【整形家族】" class="headerlink" title="【整形家族】"></a>【整形家族】</h3><p>（1）char: unsigned char 和 signed char(注：char虽然是字符类型，但是本质上以ASCII码，即数字存储)     占位1字节</p><p>（2）short: unsigned short int 和 signed short int                                           占位2字节</p><p>（3）int: unsigned int 和 signed int                                                         占位4字节</p><p>（4）long: unsigned long int 和 signed long int                                              占位4字节</p><h3 id="【浮点数家族】"><a href="#【浮点数家族】" class="headerlink" title="【浮点数家族】"></a>【浮点数家族】</h3><p>（1）float                                                                                   占位4字节</p><p>（2）double                                                                                  占位8字节</p><h3 id="【构造类型（自定义类型）】"><a href="#【构造类型（自定义类型）】" class="headerlink" title="【构造类型（自定义类型）】"></a>【构造类型（自定义类型）】</h3><p>（1）结构体类型（struct）</p><p>（2）数组（分为一维数组，二维数组，指针数组…）</p><p>（3）联合体（union）</p><p>（4）枚举（enum）</p><h3 id="【指针类型】"><a href="#【指针类型】" class="headerlink" title="【指针类型】"></a>【指针类型】</h3><p>（1）一级指针</p><p>（2）二级指针</p><p>（3）数组指针</p><p>（4）函数指针</p><h3 id="【空类型】"><a href="#【空类型】" class="headerlink" title="【空类型】"></a>【空类型】</h3><h2 id="【数据在内存中的存储】-1"><a href="#【数据在内存中的存储】-1" class="headerlink" title="【数据在内存中的存储】"></a>【数据在内存中的存储】</h2><h3 id="【数据的存储，需要考虑两方面，一是整数以补码的形式存储，二是大小端存储】"><a href="#【数据的存储，需要考虑两方面，一是整数以补码的形式存储，二是大小端存储】" class="headerlink" title="【数据的存储，需要考虑两方面，一是整数以补码的形式存储，二是大小端存储】"></a>【数据的存储，需要考虑两方面，一是整数以补码的形式存储，二是大小端存储】</h3><h4 id="【补码的表示】"><a href="#【补码的表示】" class="headerlink" title="【补码的表示】"></a>【补码的表示】</h4><p>（1）正整数：原码、反码、补码相同</p><p>（2）负整数：以signed int a &#x3D; -10为例</p><p>原码:10000000000000000000000000001010</p><p>反码:11111111111111111111111111110101</p><p>补码:11111111111111111111111111110110</p><h4 id="【大小端存储】"><a href="#【大小端存储】" class="headerlink" title="【大小端存储】"></a>【大小端存储】</h4><p><strong>数据的低位在低地址为小端存储。</strong></p><p><strong>数据的低位在高地址为大端存储。</strong></p><h5 id="【那么何为数据的低位和高位呢？】"><a href="#【那么何为数据的低位和高位呢？】" class="headerlink" title="【那么何为数据的低位和高位呢？】"></a>【那么何为数据的低位和高位呢？】</h5><p>二进制：10111100000（左边高位，右边低位），八进制，十六进制等同上，权值高的是数据的高位。</p><h5 id="【如何判断计算机大小端？】"><a href="#【如何判断计算机大小端？】" class="headerlink" title="【如何判断计算机大小端？】"></a>【如何判断计算机大小端？】</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>;<span class="comment">//补码是00000000000000000000000000000001</span></span><br><span class="line">    <span class="type">char</span>* b = (<span class="type">char</span>*)&amp;a;</span><br><span class="line">    <span class="keyword">if</span> (*b == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;大端存储&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;小端存储&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="【整形的存储】"><a href="#【整形的存储】" class="headerlink" title="【整形的存储】"></a>【整形的存储】</h3><p>以补码形式在内存中存储，存储时注意大小端的问题</p><h3 id="【浮点数的存储】"><a href="#【浮点数的存储】" class="headerlink" title="【浮点数的存储】"></a>【浮点数的存储】</h3><p><strong>【注】：浮点数在内存中存储仍有大小端的问题</strong></p><h4 id="【浮点数的表示】"><a href="#【浮点数的表示】" class="headerlink" title="【浮点数的表示】"></a>【浮点数的表示】</h4><p>根据国际标准IEEE（电气电子工程师学会）754，任意一个二进制浮点数V都可以表示为以下形式：</p><p>V &#x3D; （-1）^ S * M * 2 ^ E</p><p>S：符号位，只能是0或者1，当S为0时，V是正数。当S为1时，V是负数。</p><p>M：有效数，位于1到2区间内</p><p>E：指数位</p><p>eg：</p><p><img src="https://c2.im5i.com/2023/01/20/Yuk5n.png" alt="Yuk5n.png"></p><h4 id="【浮点数的存储】-1"><a href="#【浮点数的存储】-1" class="headerlink" title="【浮点数的存储】"></a>【浮点数的存储】</h4><h5 id="【float类型】"><a href="#【float类型】" class="headerlink" title="【float类型】"></a>【float类型】</h5><p>IEEE754规定：对于32位的float类型，最高的一位是符号位S，接着8位是指数E，剩下的23位是有效数M。</p><p><img src="https://c2.im5i.com/2023/01/20/Y51Al.png" alt="Y51Al.png"></p><h5 id="【double类型】"><a href="#【double类型】" class="headerlink" title="【double类型】"></a>【double类型】</h5><p>IEEE754规定：对于64位的double类型，最高的一位是符号位S，接着11位是指数E，剩下的52位是有效数M。</p><p><img src="https://c2.im5i.com/2023/01/20/Y5wIP.png" alt="Y5wIP.png"></p><h5 id="【浮点数有高低地址吗？】"><a href="#【浮点数有高低地址吗？】" class="headerlink" title="【浮点数有高低地址吗？】"></a>【浮点数有高低地址吗？】</h5><p>当然！浮点数在计算机中存储也需要考虑大小端的问题，对于浮点数，右边是低地址，左边是高地址</p><h5 id="【S、M、E怎么存入呢？】"><a href="#【S、M、E怎么存入呢？】" class="headerlink" title="【S、M、E怎么存入呢？】"></a>【S、M、E怎么存入呢？】</h5><p>（1）S，就直接存在第一位即可，0&#x2F;1</p><p>（2）M，它的范围是（1，2），所以存入为了节省一位有效位，只存储小数点后面的位数，如 M &#x3D; 1.0101，那么在M中就只存0101，剩余的位数补0</p><p>（3）E，IEEE规定指数位E是无符号数，而用 V &#x3D; （-1）^ S * M * 2 ^ E 来表示时，E是有符号数，可能是负数【eg，0.1 &#x3D; (-1)^0 * 1.0 * 2^(-1)】，在8位指数位下，E ∈（-127，128），在11位指数位下，E ∈（-1023，1024）</p><p>​1、float，指数位E是8位，对于无符号数来说，E ∈（0.255），所以要在原本的E的基础上加上127，使它转化成无符号数。</p><p>​2、double，指数位E是11位，对于无符号数来说，E ∈（0.2047），所以要在原本的E的基础上加上1023，使它转化成无符号数。</p><h5 id="【S、M、E怎么取出呢？】"><a href="#【S、M、E怎么取出呢？】" class="headerlink" title="【S、M、E怎么取出呢？】"></a>【S、M、E怎么取出呢？】</h5><p>（1）S，就直接取出第一位即可，0&#x2F;1</p><p>（2）M，取出小数点后面的位数后，再加上1.0即可，当E为全0时，加上0.0</p><p>（3）E，分为三种情况</p><p>​1、E不是全0或全1</p><p>​float，直接减127，double，直接减1023</p><p>​2、E是全0</p><p>​0-127后，得到E是-127，由 V &#x3D; （-1）^ S * M * 2 ^ E 表达式可知，V非常小，所以IEEE规定，M取出后直接在前面加上0.0</p><p>​0-1023后，同上</p><p>​3、E是全1</p><p>​float，11111111（十进制255）-127，得到E是128，由 V &#x3D; （-1）^ S * M * 2 ^ E 表达式可知，V表示无穷大，无意义。</p><p>​double，11111111111（十进制2047）-1023，得到E是1024，由 V &#x3D; （-1）^ S * M * 2 ^ E 表达式可知，V表示无穷大，无意义。</p><h3 id="【构造类型（自定义类型）的存储-先以数组为例，其他待续…-】"><a href="#【构造类型（自定义类型）的存储-先以数组为例，其他待续…-】" class="headerlink" title="【构造类型（自定义类型）的存储(先以数组为例，其他待续…)】"></a>【构造类型（自定义类型）的存储(先以数组为例，其他待续…)】</h3><p>数组在地址中始终是数组的低位元素在低地址，高位元素在高地址。</p><p>其中一个元素的存储符合大小端的规则。（见1.2.2图）</p><h3 id="【指针类型的存储】"><a href="#【指针类型的存储】" class="headerlink" title="【指针类型的存储】"></a>【指针类型的存储】</h3><p>待续…</p>]]></content>
    
    
    <summary type="html">数据在内存中的存储</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Markdown语法学习以及利用typora绘图</title>
    <link href="http://8-u.github.io/posts/7207d55e.html"/>
    <id>http://8-u.github.io/posts/7207d55e.html</id>
    <published>2023-01-16T10:40:46.000Z</published>
    <updated>2023-01-16T10:55:57.939Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Typora绘图"><a href="#Typora绘图" class="headerlink" title="Typora绘图"></a>Typora绘图</h1><h2 id="饼状图（Click-the-Photo）"><a href="#饼状图（Click-the-Photo）" class="headerlink" title="饼状图（Click the Photo）"></a>饼状图（Click the Photo）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pie</span><br><span class="line">title 暗网占比</span><br><span class="line">&quot;色情&quot;:452</span><br><span class="line">&quot;毒品&quot;:1265</span><br><span class="line">&quot;比特币&quot;:569</span><br></pre></td></tr></table></figure><h2 id="时序图（Click-the-Photo）"><a href="#时序图（Click-the-Photo）" class="headerlink" title="时序图（Click the Photo）"></a>时序图（Click the Photo）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Markdown语法学习以及利用typora绘图</summary>
    
    
    
    
  </entry>
  
</feed>
